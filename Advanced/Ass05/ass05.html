<html>
<head>
<title>Example 8</title>

<!--
  CanvasMatrix class
  (c) Apple Inc
  -->
<script src="CanvasMatrix.js" type="text/javascript"></script>

<!--
  Vertex shader
  -->
  <script id="shader-vs" type="x-shader/x-vertex"> 
   precision highp float;
   attribute vec3 XYZ;
   attribute vec3 RGB;
   attribute vec2 TEX;
   attribute vec3 NORM;
   
   uniform mat4 ProjectionMatrix;
   uniform mat4 ModelviewMatrix;
   uniform mat4 NormalMatrix;
   
   uniform vec3 lightPosition;
   
   varying vec3 col;
   varying highp vec2 vTextureCoord;
   varying highp vec3 vLighting;
   
   void main(void)
   {
      col = RGB;
      
      // Interpolate the Texuture Coordinates
      vTextureCoord = TEX;
     
      // Lighting
      vec3 ambient = vec3(0.2);
      vec3 dirLightColor = vec3(0.5, 0.5, 0.5);
      
      vec4 tnorm = NormalMatrix * vec4(NORM, 1.0);
      
      float dirLightVal = max(dot(tnorm.xyz, lightPosition), 0.0);
      vLighting = ambient + (dirLightColor * dirLightVal);
      
      // Vertex Position
      gl_Position = ProjectionMatrix * ModelviewMatrix * vec4(XYZ,1);
   }
</script> 
 
<!--
  Fragment shader
  -->
<script id="shader-fs" type="x-shader/x-fragment"> 
	precision highp float;
	varying vec3 col;
	varying highp vec3 vLighting;
	varying highp vec2 vTextureCoord;
	uniform sampler2D uSampler;
	void main(void)
	{
		vec4 tex = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
		gl_FragColor = vec4(col * tex.rgb * vLighting, 1);
	}
</script> 

<!--
  WebGL program
  -->
<script type="text/javascript"> 

//
// Global Vars
// 
var gl;
var canvas;

var vertBuffer;
var rgbBuffer;
var texBuffer;
var normalBuffer;

var vertPosAttr;
var vertRGBAttr;
var vertTexAttr;
var vertNormAttr;

var displayCall;
var doAnimate = false;

var doAnimateLight = false;
var lightDist = 2.0;
var lightTH = 0;
var lightPH = 90;
var lightPos = [0, 0, 0]; // Calculated

function orbit(value, amount) {
	value += amount;
	value %= 360;
	return value;
}

//
// Helper Trig
//
function Cos(th) {
	return Math.cos(Math.PI / 180.0 * th)
}

function Sin(th) {
	return Math.sin(Math.PI / 180.0 * th)
}

//
//  Compile a shader
//
function CompileShader(gl,id)
{
   //  Get shader by id
   var src = document.getElementById(id);
   //  Create shader based on type setting
   var shader;
   if (src.type == "x-shader/x-fragment")
      shader = gl.createShader(gl.FRAGMENT_SHADER);
   else if (src.type == "x-shader/x-vertex")
      shader = gl.createShader(gl.VERTEX_SHADER);
   else
      return null;
   //  Read source into str
   var str = "";
   var k = src.firstChild;
   while (k)
   {
      if (k.nodeType == 3) str += k.textContent;
      k = k.nextSibling;
   }
   gl.shaderSource(shader, str);
   //  Compile the shader
   gl.compileShader(shader);
   //  Check for errors
   if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
      alert(gl.getShaderInfoLog(shader));
   //  Return shader
   return shader;
}

//
//  Compile shader program
//
function CompileShaderProg(gl,vert,frag)
{
   //  Compile the program
   var prog  = gl.createProgram();
   gl.attachShader(prog , CompileShader(gl,vert));
   gl.attachShader(prog , CompileShader(gl,frag));
   gl.linkProgram(prog);
   //  Check for errors
   if (gl.getProgramParameter(prog, gl.LINK_STATUS) == 0)
      alert(gl.getProgramInfoLog(prog));
   //  Return program
   return prog;
}

//
// Initialize Texture Data
//
var cubeTex;
var cubeImage;
function initTextures() {
	cubeTex = gl.createTexture()
	gl.bindTexture(gl.TEXTURE_2D, cubeTex);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
					new Uint8Array([255, 0, 0, 255]));
	
	cubeImage = new Image();
	cubeImage.src = "cube.jpg";

	cubeImage.onload = function () { handleTexLoaded(cubeImage, cubeTex); }
}

function handleTexLoaded (image, texture) {
	console.log("Tex Loaded " + image);
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);

	gl.generateMipmap(gl.TEXTURE_2D);

}

function webGLStart()
{
   //  Set canvas
   canvas = document.getElementById("canvas");
   //  Select canvas size
   var size = Math.min(window.innerWidth,window.innerHeight) / 1.25;
   canvas.width  = size;
   canvas.height = size;
   
   //  Start WebGL
   if (!window.WebGLRenderingContext)
   {
      alert("Your browser does not support WebGL. See http://get.webgl.org");
      return;
   }
   try
   {
      gl = canvas.getContext("experimental-webgl");
   }
   catch(e)
   {}
   if (!gl)
   {
      alert("Can't get WebGL");
      return;
   }

   //  Set viewport to entire canvas
   gl.viewport(0,0,size,size);

   //  Load Shader
   var prog = CompileShaderProg(gl,"shader-vs","shader-fs");

   //  Set program
   gl.useProgram(prog);
   
   // Enable Attribute Arrays
   vertPosAttr = gl.getAttribLocation(prog, "XYZ");
   gl.enableVertexAttribArray(vertPosAttr);
   
   vertTexAttr = gl.getAttribLocation(prog, "TEX");
   gl.enableVertexAttribArray(vertTexAttr);
   
   vertRGBAttr = gl.getAttribLocation(prog, "RGB");
   gl.enableVertexAttribArray(vertRGBAttr);   
   
   vertNormAttr = gl.getAttribLocation(prog, "NORM");
   gl.enableVertexAttribArray(vertNormAttr);

   //  Set projection
   var ProjectionMatrix = new CanvasMatrix4();
   ProjectionMatrix.ortho(-2.5,+2.5,-2.5,+2.5,-2.5,+2.5);

   //  Vertex array count
   var n = 36;
   //  Cube vertex coordinates
   var xyz = 
   [
      -1,-1, 1, +1,-1, 1, -1,+1, 1,    -1,+1, 1, +1,-1, 1, +1,+1, 1,
      +1,-1,-1, -1,-1,-1, +1,+1,-1,    +1,+1,-1, -1,-1,-1, -1,+1,-1,
      +1,-1,+1, +1,-1,-1, +1,+1,+1,    +1,+1,+1, +1,-1,-1, +1,+1,-1,
      -1,-1,-1, -1,-1,+1, -1,+1,-1,    -1,+1,-1, -1,-1,+1, -1,+1,+1,
      -1,+1,+1, +1,+1,+1, -1,+1,-1,    -1,+1,-1, +1,+1,+1, +1,+1,-1,
      -1,-1,-1, +1,-1,-1, -1,-1,+1,    -1,-1,+1, +1,-1,-1, +1,-1,+1,
   ];
   vertBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER,vertBuffer);
   gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(xyz),gl.STATIC_DRAW);

   //  Cube colors
   var rgb = 
   [
      1,0,0, 1,0,0, 1,0,0,    1,0,0, 1,0,0, 1,0,0,
      0,0,1, 0,0,1, 0,0,1,    0,0,1, 0,0,1, 0,0,1,
      1,1,0, 1,1,0, 1,1,0,    1,1,0, 1,1,0, 1,1,0,
      0,1,0, 0,1,0, 0,1,0,    0,1,0, 0,1,0, 0,1,0,
      0,1,1, 0,1,1, 0,1,1,    0,1,1, 0,1,1, 0,1,1,
      1,0,1, 1,0,1, 1,0,1,    1,0,1, 1,0,1, 1,0,1,
   ];
   rgbBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER,rgbBuffer);
   gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(rgb),gl.STATIC_DRAW);
   
   // Texture Coordinates
   var tc = 
   [	
		// (s, t), (s, t), (s, t)
		0.0,0.0, 1.0,0.0, 0.0,1.0, 
		0.0,1.0, 1.0,0.0, 1.0,1.0,
		
		// (s, t), (s, t), (s, t)
		0.0,0.0, 1.0,0.0, 0.0,1.0, 
		0.0,1.0, 1.0,0.0, 1.0,1.0,

		// (s, t), (s, t), (s, t)
		0.0,0.0, 1.0,0.0, 0.0,1.0, 
		0.0,1.0, 1.0,0.0, 1.0,1.0,

		// (s, t), (s, t), (s, t)
		0.0,0.0, 1.0,0.0, 0.0,1.0, 
		0.0,1.0, 1.0,0.0, 1.0,1.0,

		// (s, t), (s, t), (s, t)
		0.0,0.0, 1.0,0.0, 0.0,1.0, 
		0.0,1.0, 1.0,0.0, 1.0,1.0, 
		
		// (s, t), (s, t), (s, t)
		0.0,0.0, 1.0,0.0, 0.0,1.0, 
		0.0,1.0, 1.0,0.0, 1.0,1.0
	];
			
	texBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tc), gl.STATIC_DRAW);

	initTextures();
	
	var normals = 
	[
		// Front
		0.0, 0.0, 1.0,
		0.0, 0.0, 1.0,
		0.0, 0.0, 1.0,
		0.0, 0.0, 1.0,
		0.0, 0.0, 1.0,
		0.0, 0.0, 1.0,
	
		// Back
		0.0, 0.0, -1.0,
		0.0, 0.0, -1.0,
		0.0, 0.0, -1.0,
		0.0, 0.0, -1.0,
		0.0, 0.0, -1.0,
		0.0, 0.0, -1.0,
	
		// Left
		1.0, 0.0, 0.0,
		1.0, 0.0, 0.0,
		1.0, 0.0, 0.0,
		1.0, 0.0, 0.0,
		1.0, 0.0, 0.0,
		1.0, 0.0, 0.0,
	
		// Right
		-1.0, 0.0, 0.0,
		-1.0, 0.0, 0.0,
		-1.0, 0.0, 0.0,
		-1.0, 0.0, 0.0,
		-1.0, 0.0, 0.0,
		-1.0, 0.0, 0.0,
	
		// Top
		0.0, 1.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 1.0, 0.0,
	
		// Bottom
		0.0, -1.0, 0.0,
		0.0, -1.0, 0.0,
		0.0, -1.0, 0.0,
		0.0, -1.0, 0.0,
		0.0, -1.0, 0.0,
		0.0, -1.0, 0.0,
	];
	
	normalBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

   //  Set state to draw scene
   gl.enable(gl.DEPTH_TEST);
   gl.clearColor(0.0,0.0,0.0,1);
   
   //  Mouse control variables
   var x0 = y0 = move  = 0;
   //  Rotation angles
   var th = ph = 0;
   
   //  Draw Scene at 30fps
	setInterval(CallDisplay, 1000/30);
	
	// Starts with animation off, show the screen
	
	Display();

   //
   //  Display the scene

	
   function CallDisplay () {
	   if (doAnimate || doAnimateLight)
			Display();
			
		// Set DOM Attributes
		document.getElementById("light_position").innerHTML = lightPos.map(function(num) { return num.toFixed(2) }).toString();
		document.getElementById("view_rotation").innerHTML = [th, ph].map(function(val) { return val.toFixed(2) }).toString();
   }
   
   function Display()
   {
      //  Clear the screen and Z buffer
      gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

      // Compute modelview matrix
      var ModelviewMatrix = new CanvasMatrix4();
      ModelviewMatrix.makeIdentity();
      ModelviewMatrix.rotate(ph,0,1,0);
      ModelviewMatrix.rotate(th,1,0,0);
      
      // Idle Motion
		if (move == 0 && doAnimate) {
			ph += 1;
			th += 1;
		}
	  
      
      // Compute The normal matrix
		var normalMatrix = new CanvasMatrix4(ModelviewMatrix);
		normalMatrix.invert();
		normalMatrix.transpose();

      // Set shader
      gl.useProgram(prog);

      //  Set projection and modelview matrixes
      gl.uniformMatrix4fv(gl.getUniformLocation(prog,"ProjectionMatrix") , false , new Float32Array(ProjectionMatrix.getAsArray()));
      gl.uniformMatrix4fv(gl.getUniformLocation(prog,"ModelviewMatrix")  , false , new Float32Array(ModelviewMatrix.getAsArray()));
	  gl.uniformMatrix4fv(gl.getUniformLocation(prog,"NormalMatrix"), false, new Float32Array(normalMatrix.getAsArray()));

		// Set Light Attributes
		lightPos = 
		[
			lightDist * Sin(lightTH) * Cos(lightPH),
			lightDist * Sin(lightPH),
			lightDist * Cos(lightTH) * Cos(lightPH)
		];
		
		if (doAnimateLight) {
			lightTH = orbit(lightTH, 1.0);
			lightPH = orbit(lightPH, -Math.random() * 3 | 0);
		}
		
		gl.uniform3f(gl.getUniformLocation(prog, "lightPosition"), lightPos[0], lightPos[1], lightPos[2]);

      //  Set up 3D vertex array
      gl.bindBuffer(gl.ARRAY_BUFFER,vertBuffer);
      gl.vertexAttribPointer(vertPosAttr,3,gl.FLOAT,false,0,0);

      //  Set up 3D color array
      gl.bindBuffer(gl.ARRAY_BUFFER,rgbBuffer);
      gl.vertexAttribPointer(vertRGBAttr,3,gl.FLOAT,false,0,0);

      // Set up 3D texture array
      gl.bindBuffer(gl.ARRAY_BUFFER,texBuffer);
      gl.vertexAttribPointer(vertTexAttr,2,gl.FLOAT,false,0,0);
      
      // Set up 3D normal array
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.vertexAttribPointer(vertNormAttr,3,gl.FLOAT,false,0,0);
            
      // Specify Texture
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, cubeTex);
      gl.uniform1i(gl.getUniformLocation(prog, "uSampler"), 0);

      //  Draw all vertexes
      gl.drawArrays(gl.TRIANGLES,0,n);

      //  Flush
      gl.flush ();
   }

   //
   //  Resize canvas
   //
   canvas.resize = function ()
   {
         var size = Math.min(window.innerWidth,window.innerHeight) / 1.25;
		canvas.width  = size;
		canvas.height = size;
      gl.viewport(0,0,size,size);
      Display();
   }

   //
   //  Mouse button pressed
   //
   canvas.onmousedown = function (ev)
   {
      move  = 1;
      x0 = ev.clientX;
      y0 = ev.clientY;
   }

   //
   //  Mouse button released
   //
   canvas.onmouseup = function (ev)
   {
      move  = 0;
   }

   //
   //  Mouse movement
   //
   canvas.onmousemove = function (ev)
   {
      if (move==0) return;
      //  Update angles
      ph -= ev.clientX-x0;
      th += ev.clientY-y0;
      //  Store location
      x0 = ev.clientX;
      y0 = ev.clientY;
      //  Redisplay
      Display();
   }
}


function clickAnimate () {
	// Because Display is an embedded function, I can't actually stop the routine and restart later
	// To get around this, I keep the interval but only call Display if doAnimate is true
	// Another alternative is probably setting Display to a global first class function
	
	doAnimate = !doAnimate;
}

function clickAnimateLight () {
	doAnimateLight = !doAnimateLight;
}

</script> 

<!--
  Web page
  -->
  
<style>
p {
	margin:0;
	padding:0;
}
button {
	margin:0;
	padding:0;
}
</style>
</head>
<body onload="webGLStart();" onresize="canvas.resize();" style="background-color:#000;color:#eee;"> 
<H1>Daniel Morrissey</H1><H2>Assignment 5</H2>
<div>
	<canvas  style="padding-left:0;padding-right:0;margin-left:auto;margin-right:auto;display:block;" id="canvas" width="500" height="500"></canvas> 
	<h4 style="padding:0;margin:0;">Controls</h4>
	<hr>
	<div style="float:left">
		<button type="button" onclick="clickAnimate()">Animate Box</button>
		<button type="button" onclick="clickAnimateLight()">Animate Light</button>
	</div>
	<div style="float:right;">
		<p style="float:left;">Light Position: </p>
		<p style="float:left;" id="light_position"></p>
		<br/>
		<p style="float:left;">View Rotation: </p>
		<p style="float:left;" id="view_rotation"></p>
	</div> 
</div>
</body>
</html>
